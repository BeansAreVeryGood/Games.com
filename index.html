<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hapara</title>
  <style>
    :root { --header-height: 96px; }
    html,body{height:100%;margin:0;font-family:system-ui,Arial,sans-serif}
    /* cookie consent popup */
    .consent {
      position:fixed;left:12px;right:12px;bottom:12px;max-width:1200px;margin:0 auto;
      background:#06202a;color:#fff;padding:12px;border-radius:8px;z-index:10000001;
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
    }
    .consent .msg{flex:1;font-size:14px}
    .consent .actions{display:flex;gap:8px}
    .consent .btn{padding:8px 12px;border-radius:6px;cursor:pointer;border:0}
    .consent .btn-accept{background:#06b6d4;color:#06202a}
    .consent .btn-decline{background:#e2e8f0;color:#06202a}
    .topbar{
      position:fixed;top:0;left:0;right:0;height:var(--header-height);
      background:#ff6600;color:#000;padding:12px;box-sizing:border-box;
      display:flex;flex-direction:column;gap:8px;align-items:center;
      z-index:9999999; /* ensure on top */
      box-shadow:0 4px 12px rgba(0,0,0,0.4);
      border-bottom:4px solid #ffff00; /* debug: bright border */
    }
    .brand{ font-weight:800;color:#06202a;font-size:18px; user-select:none; margin-bottom:4px; }
    .url-input{
      width:95%;max-width:1200px;height:44px;padding:8px 12px;
      border-radius:6px;border:3px solid #00ff00;font-size:16px;
      box-sizing:border-box;background:#ffffff;color:#000;z-index:9999999;
      outline: 3px solid #00ffff; /* debug outline */
    }
    .enter-box{
      width:120px;height:34px;display:inline-flex;align-items:center;
      justify-content:center;background:#06b6d4;color:#06202a;border-radius:6px;
      cursor:pointer;font-weight:600;user-select:none;box-shadow:0 2px 6px rgba(2,6,23,0.2)
    }
    .viewer{
      position:fixed;top:var(--header-height);left:0;right:0;bottom:0;
      width:100%;height:calc(100vh - var(--header-height));border:0;
      box-sizing:border-box;background:#fff;
    }

    /* overlay shown when iframe fails to load */
    .overlay{
      position:fixed;left:12px;right:12px;top:calc(var(--header-height) + 12px);
      max-width:1200px;margin:0 auto;background:rgba(255,255,255,0.98);
      border-radius:8px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,0.35);
      z-index:10000000;display:none;gap:8px;
    }
    .overlay.visible{ display:flex; flex-direction:column; }
    .overlay .row{ display:flex; gap:8px; align-items:center; }
    .btn-ghost{ padding:8px 12px;border-radius:6px;background:#e2e8f0;cursor:pointer; }
    .btn-primary{ padding:8px 12px;border-radius:6px;background:#06b6d4;color:#06202a;cursor:pointer; }
    .muted{ color:#374151;font-size:13px; }
    @media (max-width:480px){ :root{--header-height:120px} .enter-box{width:100px;height:36px} }
  </style>
</head>
<body>
  <div class="topbar" role="region" aria-label="URL input area">
    <div class="brand">Beans</div>
    <label style="font-size:13px;margin-bottom:4px;">
      <input id="useProxy" type="checkbox" /> Use proxy (when available)
    </label>
    <input id="urlInput" class="url-input" type="text" placeholder="Enter a URL (e.g. example.com or https://example.com)" />
    <div id="enterBtn" class="enter-box" role="button" tabindex="0">Enter</div>
    <!-- Google buttons removed per request -->
  </div>

  <!-- cookie consent popup (auto-hidden if user already consented) -->
  <div id="cookieConsent" class="consent" style="display:none" role="dialog" aria-live="polite">
    <div class="msg">This site can use a proxy and related cookies to display some sites inside the viewer. Allow use of my cookies for this purpose?</div>
    <div class="actions">
      <button id="consentYes" class="btn btn-accept">Yes, allow cookies</button>
      <button id="consentNo" class="btn btn-decline">No, thanks</button>
    </div>
  </div>
  
  <!-- allow-popups and allow-top-navigation so login flows opened by the framed page can work -->
  <iframe id="viewer" class="viewer" src="about:blank" sandbox="allow-scripts allow-forms allow-same-origin allow-popups allow-top-navigation"></iframe>

  <div id="errorOverlay" class="overlay" role="alert" aria-hidden="true">
    <div class="row"><strong id="overlayTitle">Unable to display site in the viewer</strong></div>
    <div class="row muted" id="overlayMsg">The site may block embedding (X-Frame-Options or Content-Security-Policy), be unreachable, or use mixed content.</div>
    <div class="row">
      <a id="openDirect" class="btn-primary" href="#" target="_blank" rel="noopener noreferrer">Open directly</a>
      <a id="openProxied" class="btn-primary" href="#" target="_blank" rel="noopener noreferrer" style="display:none">Open proxied</a>
      <button id="dismiss" class="btn-ghost">Dismiss</button>
    </div>
  </div>

  <script>
    // prefer local proxy on dev machine; otherwise use same origin and match protocol to avoid mixed content
    const LOCAL_PROXY = (location.protocol === 'https:') ? 'https://localhost:3000' : 'http://localhost:3000';
    // treat localhost and common private LAN addresses as "local" so PROXY_BASE points to :3000
    const isPrivateHost = (h => {
      if (!h) return false;
      if (h === 'localhost' || h === '127.0.0.1' || h === '::1') return true;
      // simple private IPv4 ranges (10.*, 172.16-31.*, 192.168.*)
      if (/^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[0-1])\.)/.test(h)) return true;
      return false;
    })(location.hostname);

    const PROXY_BASE = isPrivateHost ? LOCAL_PROXY : (location.protocol + '//' + location.host); // expects /proxy on same origin in production

    // cookie consent helpers
    const consentEl = document.getElementById('cookieConsent');
    const consentYes = document.getElementById('consentYes');
    const consentNo = document.getElementById('consentNo');
    function hasConsented(){ return localStorage.getItem('hapara_cookie_consent') === '1'; }
    function setConsent(v){
      localStorage.setItem('hapara_cookie_consent', v ? '1' : '0');
      // if consenting, enable proxy checkbox so proxied cookies will be used
      const cb = document.getElementById('useProxy');
      if(cb && v) cb.checked = true;
    }
    // show consent UI if not set
    if(!hasConsented()){
      consentEl.style.display = 'flex';
    }
    consentYes && consentYes.addEventListener('click', () => {
      setConsent(true);
      // hide consent UI
      consentEl.style.display = 'none';
    });
    consentNo && consentNo.addEventListener('click', () => {
      setConsent(false);
      consentEl.style.display = 'none';
    });

    // small timeout helper
    function timeout(ms, p) {
      return new Promise((res, rej) => {
        const id = setTimeout(() => { clearTimeout(id); rej(new Error('timeout')); }, ms);
        p.then(v => (clearTimeout(id), res(v))).catch(e => (clearTimeout(id), rej(e)));
      });
    }

    // check if proxy is reachable
    async function checkProxyReachable() {
      try {
        // try /health on PROXY_BASE (if PROXY_BASE is same origin this will be relative)
        const healthUrl = (PROXY_BASE === location.origin) ? '/proxy/health' : (PROXY_BASE + '/health');
        const r = await timeout(2500, fetch(healthUrl, { method: 'GET', cache: 'no-store', mode: 'cors' }));
        return r.ok;
      } catch (e) {
        return false;
      }
    }

    const input = document.getElementById('urlInput');
    const btn = document.getElementById('enterBtn');
    const viewer = document.getElementById('viewer');
    const overlay = document.getElementById('errorOverlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayMsg = document.getElementById('overlayMsg');
    const openDirect = document.getElementById('openDirect');
    const openProxied = document.getElementById('openProxied');
    const dismiss = document.getElementById('dismiss');

    function hasScheme(s){ return /^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(s); }
    function normalizeCandidates(raw){
      raw = (raw||'').trim();
      if(!raw) return [];
      if(hasScheme(raw)) return [raw];
      return ['https://' + raw, 'http://' + raw];
    }
    function showOverlay(msg, directUrl, proxiedUrl) {
      overlayTitle.textContent = 'Unable to display site in the viewer';
      overlayMsg.textContent = msg;
      openDirect.href = directUrl;
      if (proxiedUrl) {
        openProxied.href = proxiedUrl;
        openProxied.style.display = 'inline-block';
      } else {
        openProxied.style.display = 'none';
      }
      overlay.classList.add('visible');
      overlay.setAttribute('aria-hidden','false');
    }
    function hideOverlay(){ overlay.classList.remove('visible'); overlay.setAttribute('aria-hidden','true'); }

    async function loadUrl(){
      hideOverlay();
      const raw = input.value;
      const candidates = normalizeCandidates(raw);
      if(candidates.length === 0){ viewer.src = 'about:blank'; return; }

      const proxyReachable = await checkProxyReachable();

      // if user consented, prefer proxy usage for domains that need cookies (e.g. google)
      const userConsented = hasConsented();

      const buildSrc = (u, useProxy) => {
        if(!useProxy) return u;
        // use same-origin proxy if PROXY_BASE == location.origin, otherwise use explicit PROXY_BASE
        const base = (PROXY_BASE === location.origin) ? '/proxy' : (PROXY_BASE + '/proxy');
        return base + '?url=' + encodeURIComponent(u);
      };

      let tried = 0;
      const timeoutPerAttempt = 6000;

      async function tryNext() {
        if (tried >= candidates.length) {
          const last = candidates[candidates.length-1];
          const proxiedUrl = proxyReachable ? ( (PROXY_BASE === location.origin ? '/proxy' : (PROXY_BASE + '/proxy')) + '?url=' + encodeURIComponent(last) ) : null;
          showOverlay('All attempts failed. The site likely blocks framing or is unreachable. Use the buttons to open directly or via the proxy (if available).', last, proxiedUrl);
          return;
        }
        const url = candidates[tried++];
        let loaded = false;
        const onload = () => { loaded = true; viewer.removeEventListener('load', onload); hideOverlay(); };
        viewer.addEventListener('load', onload);

        // determine whether to use proxy for this URL
        const useProxyEl = document.getElementById('useProxy');
        let useProxyForThis = !!(useProxyEl && useProxyEl.checked);
        try {
          const host = new URL(url).hostname;
          // auto-enable proxy for Google domains when proxy is reachable or user consented
          if (/(\.|^)google\./i.test(host) && proxyReachable && userConsented) useProxyForThis = true;
          // also auto-enable if user actively checked the box
          if (/(\.|^)google\./i.test(host) && proxyReachable && useProxyEl && useProxyEl.checked) useProxyForThis = true;
        } catch (e) { /* ignore parse errors, fall back to checkbox */ }

        // try direct first (better for sites that require top-level cookies)
        viewer.src = buildSrc(url, false);

        await new Promise(resolve => setTimeout(resolve, timeoutPerAttempt));
        if (loaded) return;
        viewer.removeEventListener('load', onload);

        // if direct failed and proxy is reachable, try proxy
        if (proxyReachable) {
          viewer.addEventListener('load', onload);
          // prefer proxy for Google or when user checked proxy / consented
          viewer.src = buildSrc(url, useProxyForThis);
          await new Promise(resolve => setTimeout(resolve, timeoutPerAttempt));
          if (loaded) return;
          viewer.removeEventListener('load', onload);
        }

        // next candidate
        tryNext();
      }

      tryNext();
    }

    // wire UI
    btn.addEventListener('click', loadUrl);
    btn.addEventListener('keydown', e => { if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); loadUrl(); } });
    input.addEventListener('keydown', e => { if(e.key === 'Enter') loadUrl(); });
    dismiss.addEventListener('click', hideOverlay);

    // removed explicit Google buttons; proxy will be auto used for google domains when reachable

    // helpful console message
    console.log('PROXY_BASE =', PROXY_BASE);
    console.log('If remote machines cannot reach your proxy, host the proxy on a network-accessible host (same origin as the site or public host).');
  </script>
</body>
</html>